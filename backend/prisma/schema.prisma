// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Enums matching frontend exactly
enum UserRole {
  ADMIN
  DESIGNER
  DEV_MANAGER
  QA_ENGINEER
}

enum ProjectStage {
  UPCOMING
  DESIGN
  DEVELOPMENT
  QA
  SEND_TO_CLIENT
  ADMIN_REVIEW
  SENT_TO_CLIENT
  COMPLETED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model Tenant {
  id        String    @id @default(uuid())
  name      String
  createdAt DateTime  @default(now())
  
  users     User[]
  projects  Project[]
  comments  Comment[]
  history   HistoryItem[]
  scores    ScoreEntry[]
  notifications Notification[]
  auditLogs     AuditLog[]
}

model AuditLog {
  id        String   @id @default(uuid())
  action    String
  target    String   // Description or ID of target
  actorId   String
  actorEmail String?
  timestamp DateTime @default(now())
  metadata  Json?

  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@index([timestamp])
}

model AuditOutbox {
  id        String   @id @default(uuid())
  action    String
  target    String
  actorId   String
  actorEmail String?
  tenantId  String
  metadata  Json?
  createdAt DateTime @default(now())
}

model User {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  password  String   // F-002: Remediation - Mandatory Password
  role      UserRole
  avatar    String?

  isActive          Boolean   @default(true)
  lastRevocationAt  DateTime? // Comparing with JWT iat ensures revocation works without changing auth controller

  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])

  // Relations
  projectsDesigned Project[] @relation("AssignedDesigner")
  projectsManaged  Project[] @relation("AssignedDevManager")
  projectsQA       Project[] @relation("AssignedQA")
  
  comments         Comment[]
  scores           ScoreEntry[] 
  notifications    Notification[]
  resetTokens      PasswordResetToken[]
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  tokenHash String   @unique // F-006: Remediation - Store Hash Only
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tokenHash])
  @@index([userId])
}

model Project {
  id              String       @id @default(uuid())
  name            String
  clientName      String
  scope           String
  priority        Priority
  stage           ProjectStage
  overallDeadline DateTime
  currentDeadline DateTime?
  
  tenantId        String
  tenant          Tenant       @relation(fields: [tenantId], references: [id])

  // Relations
  assignedDesignerId   String?
  assignedDesigner     User?   @relation("AssignedDesigner", fields: [assignedDesignerId], references: [id])
  
  assignedDevManagerId String?
  assignedDevManager   User?   @relation("AssignedDevManager", fields: [assignedDevManagerId], references: [id])
  
  assignedQAId         String?
  assignedQA           User?   @relation("AssignedQA", fields: [assignedQAId], references: [id])

  // JSON Checklists for direct mapping to frontend
  designChecklist Json[]
  devChecklist    Json[]
  qaChecklist     Json[]
  finalChecklist  Json[]

  isDelayed    Boolean @default(false)
  qaFailCount  Int     @default(0)

  createdAt    DateTime @default(now())
  completedAt  DateTime?

  comments     Comment[]
  history      HistoryItem[]
  scores       ScoreEntry[]

  @@index([tenantId])
  @@index([assignedDevManagerId])
  @@index([tenantId, createdAt])
}

model Comment {
  id        String   @id @default(uuid())
  text      String
  timestamp DateTime @default(now())
  
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  
  projectId String
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
}

model HistoryItem {
  id        String       @id @default(uuid())
  stage     ProjectStage
  action    String
  timestamp DateTime     @default(now())
  userId    String       
  rejectionSnapshot Json?

  projectId String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
}

model ScoreEntry {
  id        String   @id @default(uuid())
  date      DateTime @default(now())
  points    Int
  reason    String
  
  projectId String
  project   Project  @relation(fields: [projectId], references: [id])
  
  userId    String
  user      User     @relation(fields: [userId], references: [id])

  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])

  @@index([tenantId, userId])
  @@index([tenantId, date])
}

model Notification {
  id        String   @id @default(uuid())
  title     String
  message   String
  type      String   // 'assignment', 'alert', 'info'
  read      Boolean  @default(false)
  timestamp DateTime @default(now())

  userId    String
  user      User     @relation(fields: [userId], references: [id])

  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])

  @@index([userId])
  @@index([tenantId])
  @@index([tenantId, timestamp])
}
